
----------------- Поток лексем ---------------------
01 tfi(si){rl;}
02 tfi(si,si){rl;}
04 tfi(ti){
05 ti;
06 ti;
07 h(i){
08 al:{rl;}
09 d:{
10 i=ivl;
11 i=ivi(i);
12 ri;
13 }
14 }
15 rl;
16 }
18 tfi(ti,ti){
19 ti;
21 ovl;
23 h(ivi){
24 al:{
25 ovl;
26 }
27 al:{
28 h(ivi){
29 al:{ovl;}
30 d:{ovl;}
31 }
33 }
34 d:{}
35 }
36 rl;
37 }
39 m{
40 ti;
41 ti;
42 ti;
43 si;
44 ci;
45 ti;
47 ovl;
49 ovl;
51 i=l;
52 ovl;
53 ovi;
55 i=l;
56 ovl;
57 ovi;
59 i=l;
60 ovl;
61 ovi;
63 ovl;
64 i=ivl;
65 ovl;
66 ovi;
68 ovl;
69 i=l;
70 i=i(i);
71 ovl;
72 ovivl;
74 i=l;
75 i=i(i,l);
76 ovl;
77 ovi;
79 ovl;
80 i(l,l);
81 i(l,l);
82 i(l,l);
84 ovl;
85 i=i(l);
86 ovl;
87 ovi;
89 ovl;
90 }


-----Таблица лексем после преобразования в ПОЛИЗ (Сырая)

----------------- Поток лексем ---------------------
01 tfi(si){rl;}
02 tfi(si,si){rl;}
04 tfi(ti){
05 ti;
06 ti;
07 h(i){
08 al:{rl;}
09 d:{
10 i=ilv;
11 i=ii@v;
12 ri;
13 }
14 }
15 rl;
16 }
18 tfi(ti,ti){
19 ti;
21 olv;
23 h(iiv){
24 al:{
25 olv;
26 }
27 al:{
28 h(iiv){
29 al:{olv;}
30 d:{olv;}
31 }
33 }
34 d:{}
35 }
36 rl;
37 }
39 m{
40 ti;
41 ti;
42 ti;
43 si;
44 ci;
45 ti;
47 olv;
49 olv;
51 i=l;
52 olv;
53 oiv;
55 i=l;
56 olv;
57 oiv;
59 i=l;
60 olv;
61 oiv;
63 olv;
64 i=ilv;
65 olv;
66 oiv;
68 olv;
69 i=l;
70 i=i@;
71 olv;
72 oilvv;
74 i=l;
75 i=li@;
76 olv;
77 oiv;
79 olv;
80 ll@;
81 ll@;
82 ll@;
84 olv;
85 i=l@;
86 olv;
87 oiv;
89 olv;
90 }


----------------- Декодированная Польская запись (ПОЛИЗ) ---------------------
Номер строки | Выражение в ПОЛИЗ
------------------------------------------------------------------------------
01           | strtoint s return 0 ;
02           | stcmp s1 s2 return 0 ;
04           | recCheck n 
05           | res ;
06           | next ;
07           | n 
08           | 0 return 0 ;
09           | 10           | next = n 1 - ;
11           | res = n next CALL1 + ;
12           | return res ;
13           | 14           | 15           | return 0 ;
16           | 18           | logTest v1 v2 
19           | diff ;
21           | cout "--- Logic Comparison in Switch ---" < ;
23           | v1 v2 > 
24           | 1 
25           | cout "Result: v1 GREATER than v2" < ;
26           | 27           | 0 
28           | v1 v2 == 
29           | 1 cout "Result: v1 EQUAL v2" < ;
30           | cout "Result: v1 LESS than v2" < ;
31           | 33           | 34           | 35           | 36           | return 0 ;
37           | 39           | 40           | hexVal ;
41           | binVal ;
42           | intVal ;
43           | strVal ;
44           | charVal ;
45           | logicRes ;
47           | cout "=== ULTRA HARDCORE TEST START ===" < ;
49           | cout "1. Literals and Types" < ;
51           | hexVal = 127 ;
52           | cout "Hex 0x7F (Max 1-byte):" < ;
53           | cout hexVal < ;
55           | binVal = 3 ;
56           | cout "Bin 0b11 (3):" < ;
57           | cout binVal < ;
59           | charVal = 'A' ;
60           | cout "Char Literal A (65):" < ;
61           | cout charVal < ;
63           | cout "2. One Byte Overflow" < ;
64           | intVal = hexVal 1 + ;
65           | cout "127 + 1 = -128 (Overflow Check):" < ;
66           | cout intVal < ;
68           | cout "3. String Library" < ;
69           | strVal = "100" ;
70           | intVal = strVal CALL1 ;
71           | cout "StrToInd 100 + 25:" < ;
72           | cout intVal 25 + < ;
74           | strVal = "pass" ;
75           | logicRes = "pass" strVal CALL2 ;
76           | cout "Strcmp pass vs pass (0 is equal):" < ;
77           | cout logicRes < ;
79           | cout "4. Comparisons via Switch" < ;
80           | 5 10 CALL2 ;
81           | 10 5 CALL2 ;
82           | 5 5 CALL2 ;
84           | cout "5. Recursion Sum(5) = 5+4+3+2+1" < ;
85           | intVal = 5 CALL1 ;
86           | cout "Expect 15:" < ;
87           | cout intVal < ;
89           | cout "=== ULTRA HARDCORE TEST END ===" < ;
90           | 
------------------------------------------------------------------------------
